create table "public"."commands" (
    "created_at" timestamp with time zone default now(),
    "name" text not null,
    "cooldown" bigint not null
);


create table "public"."showcases" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" text not null,
    "description" text not null,
    "link" text not null,
    "supabase_relation" text not null,
    "need_contributors" boolean not null,
    "thumbnail" text,
    "id_message" text not null,
    "id_author" text not null
);


create table "public"."user_cooldowns" (
    "id" bigint generated by default as identity not null,
    "id_user" text not null,
    "command_name" text not null,
    "last_used" timestamp without time zone not null
);


CREATE UNIQUE INDEX commands_name_key ON public.commands USING btree (name);

CREATE UNIQUE INDEX commands_pkey ON public.commands USING btree (name);

CREATE UNIQUE INDEX cooldowns_pkey ON public.user_cooldowns USING btree (id);

CREATE UNIQUE INDEX showcases_id_message_key ON public.showcases USING btree (id_message);

CREATE UNIQUE INDEX showcases_pkey ON public.showcases USING btree (id);

alter table "public"."commands" add constraint "commands_pkey" PRIMARY KEY using index "commands_pkey";

alter table "public"."showcases" add constraint "showcases_pkey" PRIMARY KEY using index "showcases_pkey";

alter table "public"."user_cooldowns" add constraint "cooldowns_pkey" PRIMARY KEY using index "cooldowns_pkey";

alter table "public"."commands" add constraint "commands_name_key" UNIQUE using index "commands_name_key";

alter table "public"."showcases" add constraint "showcases_id_message_key" UNIQUE using index "showcases_id_message_key";

alter table "public"."user_cooldowns" add constraint "user_cooldowns_command_name_fkey" FOREIGN KEY (command_name) REFERENCES commands(name) not valid;

alter table "public"."user_cooldowns" validate constraint "user_cooldowns_command_name_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.insert_user_cooldown()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if the row exists
    IF EXISTS (SELECT 1 FROM user_cooldowns WHERE id_user = NEW.id_user AND command_name = NEW.command_name) THEN
        -- Row exists, update it
        UPDATE user_cooldowns
        SET last_used = NEW.last_used
        WHERE id_user = NEW.id_user AND command_name = NEW.command_name;

        RETURN NULL;
    ELSE
      RETURN NEW;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_default_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.id = coalesce(NEW.id, nextval('commands_id_seq'));
  RETURN NEW;
END;
$function$
;

CREATE TRIGGER insert_user_cooldown_trigger BEFORE INSERT ON public.user_cooldowns FOR EACH ROW EXECUTE FUNCTION insert_user_cooldown();


